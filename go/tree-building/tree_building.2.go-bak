// Package tree offers a tree validation and construction method
package tree

import (
	"errors"
	"sort"
)

// Record represents a record element
type Record struct {
	ID, Parent int
}

// Node represents a node in the tree
type Node struct {
	ID       int
	Children []*Node
}

// checkRecord checks the validity of a record
func checkRecord(record Record, index int) error {

	if record.ID != index {
		return errors.New("Invaid record ID.")
	}

	if record.ID == 0 && record.Parent != 0 {
		return errors.New("Invalid root record.")
	}

	if record.ID != 0 && record.ID <= record.Parent {
		return errors.New("Invalid child record.")
	}

	return nil
}

// Build creates a tree of the given set of records
func Build(records []Record) (*Node, error) {
	if len(records) == 0 {
		return nil, nil
	}

	// sort the records
	sort.Slice(records, func(i, j int) bool { return records[i].ID < records[j].ID })

	nodes := map[int]*Node{}

	// check records
	for i := range records {
		if err := checkRecord(records[i], i); err != nil {
			return nil, err
		}
	}

	// build the tree
	for i := range records {

		record := records[i]

		child := Node{record.ID, nil}
		nodes[record.ID] = &child

		if i > 0 {
			parent := nodes[record.Parent]
			parent.Children = append(parent.Children, &child)
		}
	}

	return nodes[0], nil
}
